{
  "version": 3,
  "sources": ["../src/extension.ts", "../src/panel/gameInfoPanel.ts", "../src/panel/treePanel.ts", "../src/lean/lspIntegration.ts", "../src/watcher/solutionWatcher.ts", "../src/commands/registerCommands.ts", "../src/parser/leanGameParser.ts", "../src/parser/gameLeanParser.ts", "../src/generator/solutionGenerator.ts"],
  "sourcesContent": ["import * as vscode from 'vscode'\nimport { GameInfoPanel } from './panel/gameInfoPanel'\nimport { TreePanel } from './panel/treePanel'\nimport { LspIntegration } from './lean/lspIntegration'\nimport { SolutionWatcher } from './watcher/solutionWatcher'\nimport { registerCommands, wireMessageHandlers, loadGame } from './commands/registerCommands'\n\nexport function activate(context: vscode.ExtensionContext): void {\n  const panel     = new GameInfoPanel(context.extensionUri)\n  const treePanel = new TreePanel(context.extensionUri)\n  const lsp       = new LspIntegration()\n  const watcher   = new SolutionWatcher(panel, lsp, treePanel)\n\n  context.subscriptions.push(panel, treePanel, lsp, watcher)\n\n  wireMessageHandlers(panel, treePanel, watcher)\n  registerCommands(context, panel, treePanel, watcher)\n\n  // Auto-load if a game root path is configured\n  const gameRootPath = vscode.workspace\n    .getConfiguration('leanGame')\n    .get<string>('gameRootPath')\n\n  if (gameRootPath && gameRootPath.trim() !== '') {\n    void loadGame(gameRootPath, panel, treePanel, watcher, false)\n  }\n}\n\nexport function deactivate(): void {\n  // Cleanup handled via context.subscriptions\n}\n", "import * as vscode from 'vscode'\nimport * as path from 'path'\nimport * as fs from 'fs'\nimport { CompletionStatus, GoalState, LevelData } from '../parser/types'\n\nexport class GameInfoPanel implements vscode.Disposable {\n  public static readonly viewType = 'leanGame.infoPanel'\n\n  private _panel: vscode.WebviewPanel | undefined\n  private _disposables: vscode.Disposable[] = []\n\n  private readonly _onMessage = new vscode.EventEmitter<Record<string, unknown>>()\n  readonly onMessage = this._onMessage.event\n\n  constructor(private readonly _extensionUri: vscode.Uri) {}\n\n  createOrShow(): void {\n    if (this._panel) {\n      this._panel.reveal(vscode.ViewColumn.Two)\n      return\n    }\n\n    this._panel = vscode.window.createWebviewPanel(\n      GameInfoPanel.viewType,\n      'Lean Game',\n      vscode.ViewColumn.Two,\n      {\n        enableScripts: true,\n        localResourceRoots: [vscode.Uri.joinPath(this._extensionUri, 'out', 'webview')],\n        retainContextWhenHidden: true,\n      },\n    )\n\n    this._panel.webview.html = this._getHtml(this._panel.webview)\n\n    this._panel.webview.onDidReceiveMessage(\n      (msg) => this._onMessage.fire(msg as Record<string, unknown>),\n      null,\n      this._disposables,\n    )\n\n    this._panel.onDidDispose(\n      () => { this._panel = undefined },\n      null,\n      this._disposables,\n    )\n  }\n\n  /** Send a full level update to the webview. */\n  update(level: LevelData, status: CompletionStatus): void {\n    this._post({ type: 'update', level, status })\n  }\n\n  /** Update only the completion status badge. */\n  updateCompletionStatus(status: CompletionStatus): void {\n    this._post({ type: 'statusUpdate', status })\n  }\n\n  /** Update the live proof state display. */\n  updateGoals(goals: GoalState[]): void {\n    this._post({ type: 'goalsUpdate', goals })\n  }\n\n  /** Tell the webview whether the \"Next Problem\" button should be enabled. */\n  setHasNext(hasNext: boolean): void {\n    this._post({ type: 'setHasNext', hasNext })\n  }\n\n  /** Show a plain \"no level\" state. */\n  showEmpty(): void {\n    this._post({ type: 'empty' })\n  }\n\n  private _post(msg: unknown): void {\n    this._panel?.webview.postMessage(msg)\n  }\n\n  private _getHtml(webview: vscode.Webview): string {\n    const webviewDir = vscode.Uri.joinPath(this._extensionUri, 'out', 'webview')\n\n    const htmlPath = path.join(webviewDir.fsPath, 'panel.html')\n    let html = fs.readFileSync(htmlPath, 'utf-8')\n\n    const assetUri = (name: string) =>\n      webview.asWebviewUri(vscode.Uri.joinPath(webviewDir, name)).toString()\n\n    html = html\n      .replace(/\\{\\{cspSource\\}\\}/g, webview.cspSource)\n      .replace(/\\{\\{panelCss\\}\\}/g, assetUri('panel.css'))\n      .replace(/\\{\\{katexCss\\}\\}/g, assetUri('katex.min.css'))\n      .replace(/\\{\\{katexJs\\}\\}/g, assetUri('katex.min.js'))\n      .replace(/\\{\\{panelVendorJs\\}\\}/g, assetUri('panelVendor.js'))\n      .replace(/\\{\\{panelJs\\}\\}/g, assetUri('panel.js'))\n\n    return html\n  }\n\n  dispose(): void {\n    this._panel?.dispose()\n    this._disposables.forEach((d) => d.dispose())\n    this._onMessage.dispose()\n  }\n}\n", "import * as vscode from 'vscode'\nimport * as path from 'path'\nimport * as fs from 'fs'\nimport { TreeData } from '../parser/types'\n\nexport class TreePanel implements vscode.Disposable {\n  public static readonly viewType = 'leanGame.treePanel'\n\n  private _panel: vscode.WebviewPanel | undefined\n  private _disposables: vscode.Disposable[] = []\n\n  private readonly _onMessage = new vscode.EventEmitter<Record<string, unknown>>()\n  readonly onMessage = this._onMessage.event\n\n  constructor(private readonly _extensionUri: vscode.Uri) {}\n\n  createOrShow(): void {\n    if (this._panel) {\n      this._panel.reveal(vscode.ViewColumn.Two)\n      return\n    }\n\n    this._panel = vscode.window.createWebviewPanel(\n      TreePanel.viewType,\n      'Lean Game \u2014 World Tree',\n      vscode.ViewColumn.Two,\n      {\n        enableScripts: true,\n        localResourceRoots: [vscode.Uri.joinPath(this._extensionUri, 'out', 'webview')],\n        retainContextWhenHidden: true,\n      },\n    )\n\n    this._panel.webview.html = this._getHtml(this._panel.webview)\n\n    this._panel.webview.onDidReceiveMessage(\n      (msg) => this._onMessage.fire(msg as Record<string, unknown>),\n      null,\n      this._disposables,\n    )\n\n    this._panel.onDidDispose(\n      () => { this._panel = undefined },\n      null,\n      this._disposables,\n    )\n  }\n\n  update(data: TreeData): void {\n    this._post({ type: 'treeUpdate', ...data })\n  }\n\n  private _post(msg: unknown): void {\n    this._panel?.webview.postMessage(msg)\n  }\n\n  private _getHtml(webview: vscode.Webview): string {\n    const webviewDir = vscode.Uri.joinPath(this._extensionUri, 'out', 'webview')\n    const htmlPath = path.join(webviewDir.fsPath, 'tree.html')\n    let html = fs.readFileSync(htmlPath, 'utf-8')\n\n    const assetUri = (name: string) =>\n      webview.asWebviewUri(vscode.Uri.joinPath(webviewDir, name)).toString()\n\n    html = html\n      .replace(/\\{\\{cspSource\\}\\}/g, webview.cspSource)\n      .replace(/\\{\\{treeCss\\}\\}/g, assetUri('tree.css'))\n      .replace(/\\{\\{treeJs\\}\\}/g, assetUri('tree.js'))\n\n    return html\n  }\n\n  dispose(): void {\n    this._panel?.dispose()\n    this._disposables.forEach((d) => d.dispose())\n    this._onMessage.dispose()\n  }\n}\n", "import * as vscode from 'vscode'\nimport { GoalState } from '../parser/types'\n\n// \u2500\u2500\u2500 TaggedText helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ntype TaggedText<T> =\n  | { text: string }\n  | { append: TaggedText<T>[] }\n  | { tag: [T, TaggedText<T>] }\n\nfunction taggedTextToString(t: TaggedText<unknown>): string {\n  if ('text' in t) return t.text\n  if ('append' in t) return (t as { append: TaggedText<unknown>[] }).append.map(taggedTextToString).join('')\n  if ('tag' in t) return taggedTextToString((t as { tag: [unknown, TaggedText<unknown>] }).tag[1])\n  return ''\n}\n\n// \u2500\u2500\u2500 Lean client access \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ninterface LeanClientLike {\n  sendRequest(method: string, params: unknown): Promise<unknown>\n  sendNotification(method: string, params: unknown): void | Promise<void>\n}\n\ninterface LeanExports {\n  lean4EnabledFeatures: Promise<{\n    clientProvider: {\n      getActiveClient(): LeanClientLike | undefined\n    }\n  }>\n}\n\nasync function getLeanClient(): Promise<LeanClientLike | undefined> {\n  const ext = vscode.extensions.getExtension<LeanExports>('leanprover.lean4')\n  if (!ext) {\n    console.warn('lean-game-vscode: leanprover.lean4 extension not found')\n    return undefined\n  }\n  if (!ext.isActive) {\n    await ext.activate()\n  }\n  try {\n    const features = await ext.exports.lean4EnabledFeatures\n    return features.clientProvider.getActiveClient()\n  } catch (e) {\n    console.warn('lean-game-vscode: could not get Lean client:', e)\n    return undefined\n  }\n}\n\n// \u2500\u2500\u2500 RPC session management \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ninterface Session {\n  sessionId: string\n  timer: ReturnType<typeof setInterval>\n}\n\n// \u2500\u2500\u2500 LspIntegration \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport class LspIntegration implements vscode.Disposable {\n  private sessions = new Map<string, Session>()\n\n  async getGoals(\n    uri: string,\n    position: { line: number; character: number },\n  ): Promise<GoalState[]> {\n    const client = await getLeanClient()\n    if (!client) return []\n\n    let session: Session\n    try {\n      session = await this.getOrCreateSession(client, uri)\n    } catch (e) {\n      console.warn('lean-game-vscode: could not create RPC session:', e)\n      return []\n    }\n\n    try {\n      const result = await client.sendRequest('$/lean/rpc/call', {\n        sessionId: session.sessionId,\n        method: 'Lean.Widget.getInteractiveGoals',\n        params: { textDocument: { uri }, position },\n        textDocument: { uri },\n        position,\n      })\n      return this.parseGoals(result)\n    } catch (e: unknown) {\n      const code = (e as { code?: number })?.code\n      if (code === -32900) {\n        // RpcNeedsReconnect\n        this.destroySession(uri)\n        return this.getGoals(uri, position)\n      }\n      // Suppress noise from cursor outside proof, file not ready, etc.\n      return []\n    }\n  }\n\n  private async getOrCreateSession(\n    client: LeanClientLike,\n    uri: string,\n  ): Promise<Session> {\n    const existing = this.sessions.get(uri)\n    if (existing) return existing\n\n    const result = (await client.sendRequest('$/lean/rpc/connect', { uri })) as {\n      sessionId: string\n    }\n    const sessionId = result.sessionId\n\n    const timer = setInterval(() => {\n      client.sendNotification('$/lean/rpc/keepAlive', { uri, sessionId })\n    }, 10_000)\n\n    const session: Session = { sessionId, timer }\n    this.sessions.set(uri, session)\n    return session\n  }\n\n  private destroySession(uri: string) {\n    const s = this.sessions.get(uri)\n    if (s) {\n      clearInterval(s.timer)\n      this.sessions.delete(uri)\n    }\n  }\n\n  private parseGoals(result: unknown): GoalState[] {\n    const r = result as { goals?: unknown[] } | null\n    if (!r?.goals) return []\n\n    return r.goals.map((g: unknown) => {\n      const goal = g as {\n        userName?: string\n        hyps?: Array<{\n          names: string[]\n          type: TaggedText<unknown>\n          val?: TaggedText<unknown>\n        }>\n        type: TaggedText<unknown>\n      }\n\n      return {\n        userName: goal.userName,\n        hypotheses: (goal.hyps ?? []).map((h) => ({\n          names: h.names,\n          type: taggedTextToString(h.type),\n          val: h.val ? taggedTextToString(h.val) : undefined,\n        })),\n        goalType: taggedTextToString(goal.type),\n      }\n    })\n  }\n\n  dispose() {\n    for (const s of this.sessions.values()) {\n      clearInterval(s.timer)\n    }\n    this.sessions.clear()\n  }\n}\n", "import * as fs from 'fs'\nimport * as vscode from 'vscode'\nimport { CompletionStatus, LevelData, WorldEdge } from '../parser/types'\nimport { GameInfoPanel } from '../panel/gameInfoPanel'\nimport { TreePanel } from '../panel/treePanel'\nimport { LspIntegration } from '../lean/lspIntegration'\n\n// \u2500\u2500\u2500 Completion detection \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/** Marker written by the JSON importer for levels completed in lean4game without captured code. */\nconst IMPORT_MARKER = '-- lean4game-imported: completed'\n\nfunction getCompletionStatus(uri: vscode.Uri): CompletionStatus {\n  const diags = vscode.languages.getDiagnostics(uri)\n  const errors = diags.filter(\n    (d) => d.severity === vscode.DiagnosticSeverity.Error,\n  )\n  const sorrys = diags.filter(\n    (d) =>\n      d.severity === vscode.DiagnosticSeverity.Warning &&\n      d.message.includes(\"'sorry'\"),\n  )\n  if (errors.length > 0) return 'has-errors'\n  if (sorrys.length > 0) {\n    // If the file carries the import marker, treat it as complete even with sorry\n    try {\n      if (fs.readFileSync(uri.fsPath, 'utf-8').includes(IMPORT_MARKER)) return 'complete'\n    } catch { /* ignore */ }\n    return 'incomplete'\n  }\n  return 'complete'\n}\n\n/**\n * Fast file-content check for files Lean hasn't processed yet.\n * Returns 'incomplete' if the file contains `sorry`, 'complete' otherwise.\n */\nfunction checkFileContent(filePath: string): CompletionStatus {\n  try {\n    const content = fs.readFileSync(filePath, 'utf-8')\n    if (content.includes(IMPORT_MARKER)) return 'complete'\n    return content.includes('sorry') ? 'incomplete' : 'complete'\n  } catch {\n    return 'incomplete'\n  }\n}\n\n// \u2500\u2500\u2500 SolutionWatcher \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nexport class SolutionWatcher implements vscode.Disposable {\n  private levelIndex  = new Map<string, LevelData>()\n  private statusCache = new Map<string, CompletionStatus>()\n  private sortedLevels: LevelData[] = []\n  private edges: WorldEdge[] = []\n  private disposables: vscode.Disposable[] = []\n\n  constructor(\n    private readonly panel:     GameInfoPanel,\n    private readonly lsp:       LspIntegration,\n    private readonly treePanel: TreePanel,\n  ) {}\n\n  loadLevels(levels: LevelData[], edges: WorldEdge[]): void {\n    this.levelIndex.clear()\n    this.statusCache.clear()\n    this.sortedLevels = levels\n    this.edges = edges\n\n    for (const level of levels) {\n      this.levelIndex.set(level.solutionFilePath, level)\n    }\n\n    this.disposables.forEach((d) => d.dispose())\n    this.disposables = []\n\n    this.disposables.push(\n      vscode.window.onDidChangeActiveTextEditor((editor) => {\n        if (editor) this.handleEditorChange(editor)\n      }),\n\n      vscode.languages.onDidChangeDiagnostics((e) => {\n        const activeUri = vscode.window.activeTextEditor?.document.uri\n        let activeChanged = false\n\n        for (const uri of e.uris) {\n          if (!this.levelIndex.has(uri.fsPath)) continue\n          const status = getCompletionStatus(uri)\n          this.statusCache.set(uri.fsPath, status)\n          if (activeUri && uri.toString() === activeUri.toString()) {\n            activeChanged = true\n          }\n        }\n\n        if (activeChanged && activeUri) {\n          const level  = this.levelIndex.get(activeUri.fsPath)\n          const status = this.statusCache.get(activeUri.fsPath) ?? 'incomplete'\n          if (level) {\n            this.panel.updateCompletionStatus(status)\n            if (status === 'complete') this.panel.update(level, status)\n          }\n        }\n\n        this.sendUpdates()\n      }),\n\n      vscode.window.onDidChangeTextEditorSelection(async (e) => {\n        const editor = e.textEditor\n        if (!this.levelIndex.has(editor.document.uri.fsPath)) return\n        const pos = editor.selection.active\n        const uri = editor.document.uri.toString()\n        const goals = await this.lsp.getGoals(uri, {\n          line: pos.line,\n          character: pos.character,\n        })\n        this.panel.updateGoals(goals)\n      }),\n    )\n\n    this.sendUpdates()\n    const current = vscode.window.activeTextEditor\n    if (current) this.handleEditorChange(current)\n  }\n\n  /** Return all currently loaded levels in sorted order. */\n  getLevels(): LevelData[] {\n    return this.sortedLevels\n  }\n\n  /**\n   * Remove cached statuses for the given file paths and re-send progress\n   * updates to both panels. Call after externally modifying solution files\n   * (e.g., after importing proofs from a lean4game JSON export).\n   */\n  invalidateAndRefresh(filePaths: string[]): void {\n    for (const fp of filePaths) this.statusCache.delete(fp)\n    this.sendUpdates()\n  }\n\n  /** Return the file path of the first non-complete level, or null. */\n  getNextLevelFilePath(): string | null {\n    for (const level of this.sortedLevels) {\n      const status =\n        this.statusCache.get(level.solutionFilePath) ??\n        checkFileContent(level.solutionFilePath)\n      if (status !== 'complete') return level.solutionFilePath\n    }\n    return null\n  }\n\n  private handleEditorChange(editor: vscode.TextEditor): void {\n    const level = this.levelIndex.get(editor.document.uri.fsPath)\n    if (!level) return  // non-solution file \u2014 keep last panel content\n    const status =\n      this.statusCache.get(level.solutionFilePath) ??\n      checkFileContent(level.solutionFilePath)\n    this.panel.update(level, status)\n  }\n\n  /** Push progress to both the game panel and tree panel. */\n  private sendUpdates(): void {\n    const worldMap = new Map<string, { completed: number; total: number; levels: any[] }>()\n\n    let foundNext    = false\n    let nextFilePath: string | null = null\n\n    const worldsOrdered: string[] = []\n    for (const level of this.sortedLevels) {\n      if (!worldMap.has(level.world)) {\n        worldMap.set(level.world, { completed: 0, total: 0, levels: [] })\n        worldsOrdered.push(level.world)\n      }\n      const entry  = worldMap.get(level.world)!\n      const status = this.statusCache.get(level.solutionFilePath) ?? checkFileContent(level.solutionFilePath)\n      const isNext = !foundNext && status !== 'complete'\n      if (isNext) { foundNext = true; nextFilePath = level.solutionFilePath }\n      if (status === 'complete') entry.completed++\n      entry.total++\n      entry.levels.push({\n        level:    level.level,\n        title:    level.title,\n        filePath: level.solutionFilePath,\n        status,\n        isNext,\n      })\n    }\n\n    const worlds = worldsOrdered.map((world) => {\n      const e = worldMap.get(world)!\n      return { world, levels: e.levels, completed: e.completed, total: e.total }\n    })\n\n    // Tree panel: full graph data\n    this.treePanel.update({ worlds, edges: this.edges, nextFilePath })\n\n    // Game panel: just whether there is a next level\n    this.panel.setHasNext(nextFilePath !== null)\n  }\n\n  clear(): void {\n    this.levelIndex.clear()\n    this.statusCache.clear()\n    this.sortedLevels = []\n    this.edges = []\n    this.panel.showEmpty()\n  }\n\n  dispose(): void {\n    this.disposables.forEach((d) => d.dispose())\n  }\n}\n", "import * as fs from 'fs'\nimport * as vscode from 'vscode'\nimport { parseGameDirectory } from '../parser/leanGameParser'\nimport { parseGameDependencies } from '../parser/gameLeanParser'\nimport { generateAllSolutions } from '../generator/solutionGenerator'\nimport { GameInfoPanel } from '../panel/gameInfoPanel'\nimport { TreePanel } from '../panel/treePanel'\nimport { SolutionWatcher } from '../watcher/solutionWatcher'\n\n/** Wire cross-panel message handlers (called once after all panels are created). */\nexport function wireMessageHandlers(\n  panel:      GameInfoPanel,\n  treePanel:  TreePanel,\n  watcher:    SolutionWatcher,\n): void {\n  // Game panel \u2192 extension\n  panel.onMessage((msg) => {\n    if (msg.type === 'showTree') {\n      treePanel.createOrShow()\n    } else if (msg.type === 'nextLevel') {\n      const fp = watcher.getNextLevelFilePath()\n      if (fp) {\n        void vscode.commands.executeCommand('vscode.open', vscode.Uri.file(fp), {\n          viewColumn: vscode.ViewColumn.One,\n          preserveFocus: false,\n        })\n        panel.createOrShow()\n      }\n    }\n    // 'openFile' messages are no longer sent from game panel (nav only uses showTree / nextLevel)\n  })\n\n  // Tree panel \u2192 extension\n  treePanel.onMessage((msg) => {\n    if (msg.type === 'openLevel' && typeof msg.filePath === 'string') {\n      void vscode.commands.executeCommand('vscode.open', vscode.Uri.file(msg.filePath), {\n        viewColumn: vscode.ViewColumn.One,\n        preserveFocus: false,\n      })\n      panel.createOrShow()\n    } else if (msg.type === 'jumpToNext') {\n      const fp = watcher.getNextLevelFilePath()\n      if (fp) {\n        void vscode.commands.executeCommand('vscode.open', vscode.Uri.file(fp), {\n          viewColumn: vscode.ViewColumn.One,\n          preserveFocus: false,\n        })\n        panel.createOrShow()\n      }\n    }\n  })\n}\n\nexport function registerCommands(\n  context:   vscode.ExtensionContext,\n  panel:     GameInfoPanel,\n  treePanel: TreePanel,\n  watcher:   SolutionWatcher,\n): void {\n  context.subscriptions.push(\n    vscode.commands.registerCommand('leanGame.openGame', async () => {\n      const uris = await vscode.window.showOpenDialog({\n        canSelectFolders: true,\n        canSelectFiles: false,\n        canSelectMany: false,\n        openLabel: 'Select Game Root',\n        title: 'Select Lean Game Root Directory',\n      })\n      if (!uris || uris.length === 0) return\n\n      const gameRoot = uris[0].fsPath\n      await loadGame(gameRoot, panel, treePanel, watcher, false)\n\n      await vscode.workspace\n        .getConfiguration('leanGame')\n        .update('gameRootPath', gameRoot, vscode.ConfigurationTarget.Global)\n    }),\n\n    vscode.commands.registerCommand('leanGame.showPanel', () => {\n      panel.createOrShow()\n    }),\n\n    vscode.commands.registerCommand('leanGame.showTree', () => {\n      treePanel.createOrShow()\n    }),\n\n    vscode.commands.registerCommand('leanGame.importProgress', async () => {\n      // Ensure a game is loaded\n      const gameRoot = vscode.workspace\n        .getConfiguration('leanGame')\n        .get<string>('gameRootPath')\n      if (!gameRoot?.trim()) {\n        vscode.window.showWarningMessage('No game loaded. Use \"Lean Game: Open Game\" first.')\n        return\n      }\n\n      const levels = watcher.getLevels()\n      if (levels.length === 0) {\n        vscode.window.showWarningMessage('No levels loaded. Use \"Lean Game: Open Game\" first.')\n        return\n      }\n\n      // File picker for JSON\n      const uris = await vscode.window.showOpenDialog({\n        canSelectFiles: true,\n        canSelectFolders: false,\n        canSelectMany: false,\n        openLabel: 'Import',\n        title: 'Select lean4game progress JSON export',\n        filters: { 'JSON files': ['json'] },\n      })\n      if (!uris || uris.length === 0) return\n\n      // Parse JSON \u2014 expect { data: { WorldName: { \"1\": { code, completed }, \u2026 }, \u2026 } }\n      let worldData: Record<string, Record<string, { code?: string; completed?: boolean }>>\n      try {\n        const raw    = fs.readFileSync(uris[0].fsPath, 'utf-8')\n        const parsed = JSON.parse(raw)\n        if (!parsed.data || typeof parsed.data !== 'object') {\n          throw new Error('JSON is missing a top-level \"data\" field.')\n        }\n        worldData = parsed.data\n      } catch (e: any) {\n        vscode.window.showErrorMessage(`Failed to parse progress JSON: ${e.message}`)\n        return\n      }\n\n      // Build lookup: \"WorldName:levelNumber\" \u2192 LevelData\n      const lookup = new Map<string, typeof levels[0]>()\n      for (const level of levels) {\n        lookup.set(`${level.world}:${level.level}`, level)\n      }\n\n      let imported = 0\n      let skipped  = 0\n      let missing  = 0\n      const importedPaths: string[] = []\n\n      for (const [world, levelMap] of Object.entries(worldData)) {\n        for (const [key, entry] of Object.entries(levelMap)) {\n          // Skip non-numeric keys like \"readIntro\"\n          const levelNum = parseInt(key)\n          if (isNaN(levelNum) || typeof entry !== 'object') continue\n\n          if (!entry.completed) {\n            skipped++\n            continue\n          }\n\n          const level = lookup.get(`${world}:${levelNum}`)\n          if (!level) { missing++; continue }\n\n          if (writeImportedProof(level.solutionFilePath, entry.code ?? '')) {\n            importedPaths.push(level.solutionFilePath)\n            imported++\n          } else {\n            missing++\n          }\n        }\n      }\n\n      // Refresh the tree / panel status for touched files\n      watcher.invalidateAndRefresh(importedPaths)\n\n      const parts = [`Imported ${imported} level${imported !== 1 ? 's' : ''}.`]\n      if (skipped > 0)  parts.push(`${skipped} incomplete in JSON (skipped).`)\n      if (missing > 0)  parts.push(`${missing} not found in current game.`)\n      vscode.window.showInformationMessage(parts.join('  '))\n    }),\n\n    vscode.commands.registerCommand('leanGame.regenerateSolutions', async () => {\n      const gameRoot = vscode.workspace\n        .getConfiguration('leanGame')\n        .get<string>('gameRootPath')\n      if (!gameRoot) {\n        vscode.window.showWarningMessage('No game loaded. Use \"Lean Game: Open Game\" first.')\n        return\n      }\n\n      const answer = await vscode.window.showWarningMessage(\n        'This will overwrite all auto-generated solution stubs. Your proofs will be replaced with `sorry`. Continue?',\n        { modal: true },\n        'Overwrite',\n      )\n      if (answer !== 'Overwrite') return\n\n      await loadGame(gameRoot, panel, treePanel, watcher, true)\n    }),\n  )\n}\n\nexport async function loadGame(\n  gameRoot:  string,\n  panel:     GameInfoPanel,\n  treePanel: TreePanel,\n  watcher:   SolutionWatcher,\n  overwrite: boolean,\n): Promise<void> {\n  await vscode.window.withProgress(\n    { location: vscode.ProgressLocation.Notification, title: 'Lean Game', cancellable: false },\n    async (progress) => {\n      progress.report({ message: 'Parsing levels\u2026' })\n      const levels = parseGameDirectory(gameRoot)\n\n      if (levels.length === 0) {\n        vscode.window.showWarningMessage(\n          `No levels with statements found in ${gameRoot}/Game/Levels/`,\n        )\n        return\n      }\n\n      progress.report({ message: 'Parsing dependencies\u2026' })\n      const edges = parseGameDependencies(gameRoot, levels)\n\n      progress.report({ message: `Generating ${levels.length} solution stubs\u2026` })\n      const stats = generateAllSolutions(levels, overwrite)\n\n      progress.report({ message: 'Loading level index\u2026' })\n      watcher.loadLevels(levels, edges)\n      treePanel.createOrShow()\n\n      vscode.window.showInformationMessage(\n        `Lean Game loaded: ${levels.length} levels across ${new Set(levels.map(l => l.world)).size} worlds. ` +\n          `${stats.created} solution files created, ${stats.skipped} already existed.`,\n      )\n    },\n  )\n}\n\n/**\n * Write an imported proof into a solution file.\n *\n * Finds the `:= by` marker in the file and replaces everything after it\n * with the imported tactic code (each line indented by two spaces).\n * Returns true if the file was successfully updated.\n */\n/**\n * Marker inserted before `sorry` for levels that were completed in lean4game\n * but whose proof code was not captured in the export.\n * The watcher's `checkFileContent` and `getCompletionStatus` recognise this\n * marker and report the level as 'complete' despite the presence of `sorry`.\n */\nconst IMPORT_MARKER = '-- lean4game-imported: completed'\n\n/**\n * Write an imported proof into a solution file.\n *\n * Finds the `:= by` marker in the file and replaces everything after it:\n *   \u2013 If `code` is non-empty: use the actual tactic lines (2-space indented).\n *   \u2013 If `code` is empty: write IMPORT_MARKER + sorry so the watcher treats\n *     the level as complete even though Lean would still warn about sorry.\n *\n * Skips files that already have a real proof (no `sorry` and no import marker)\n * so that user-written proofs are never overwritten by a marker-only import.\n *\n * Returns true if the file was successfully updated.\n */\nfunction writeImportedProof(filePath: string, code: string): boolean {\n  try {\n    if (!fs.existsSync(filePath)) return false\n\n    const content = fs.readFileSync(filePath, 'utf-8')\n    const byMarker = ':= by\\n'\n    const idx = content.lastIndexOf(byMarker)\n    if (idx === -1) return false\n\n    const trimmedCode = code.trim()\n\n    if (!trimmedCode) {\n      // No proof code captured \u2014 write the import marker before sorry.\n      // Skip if the file already has a real proof or the marker.\n      if (!content.includes('sorry') || content.includes(IMPORT_MARKER)) return false\n      fs.writeFileSync(\n        filePath,\n        content.slice(0, idx + byMarker.length) + `  ${IMPORT_MARKER}\\n  sorry\\n`,\n        'utf-8',\n      )\n    } else {\n      // Actual proof code \u2014 indent and write it.\n      const indented = trimmedCode\n        .split('\\n')\n        .map(line => (line ? '  ' + line : ''))\n        .join('\\n')\n      fs.writeFileSync(\n        filePath,\n        content.slice(0, idx + byMarker.length) + indented + '\\n',\n        'utf-8',\n      )\n    }\n\n    return true\n  } catch {\n    return false\n  }\n}\n", "import * as fs from 'fs'\nimport * as path from 'path'\nimport { GameHint, LevelData } from './types'\n\n// \u2500\u2500\u2500 String extraction helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/**\n * Try to close a Lean string starting right after the opening `\"`.\n * Returns the string value (unescaped) if the closing `\"` is on this\n * same line, or `null` if the string continues onto the next line.\n */\nfunction tryCloseSingleLine(rest: string): string | null {\n  let result = ''\n  let i = 0\n  while (i < rest.length) {\n    const ch = rest[i]\n    if (ch === '\\\\' && i + 1 < rest.length) {\n      // escape sequence\n      result += rest[i + 1]\n      i += 2\n      continue\n    }\n    if (ch === '\"') {\n      return result\n    }\n    result += ch\n    i++\n  }\n  return null // no closing quote on this line\n}\n\n/**\n * Extract a Lean string starting at `lineRest` (the text after the keyword +\n * space, e.g. the `\"...\"` part of `Title \"Problem 1\"`).\n *\n * - Trims leading/trailing whitespace from lineRest.\n * - If it starts with `\"` tries single-line extraction.\n * - If single-line fails (multi-line string), sets `multiLineAccum` state and\n *   returns `{ value: null, multiLine: true }` so the caller can switch modes.\n * - If the line doesn't start with `\"` returns `{ value: null, multiLine: false }`.\n */\ninterface ExtractResult {\n  value: string | null\n  multiLine: boolean\n  /** The index of the line that closed the string (for single-line = startIdx) */\n  endIdx: number\n}\n\nfunction extractLeanString(\n  lines: string[],\n  startIdx: number,\n  lineRest: string,\n): ExtractResult {\n  const trimmed = lineRest.trimStart()\n  if (!trimmed.startsWith('\"')) {\n    return { value: null, multiLine: false, endIdx: startIdx }\n  }\n\n  const afterQuote = trimmed.slice(1)\n  const single = tryCloseSingleLine(afterQuote)\n  if (single !== null) {\n    return { value: single, multiLine: false, endIdx: startIdx }\n  }\n\n  // Multi-line: accumulate until we find a line containing the closing \"\n  // Handles both:\n  //   \"                \u2190 closing \" on its own line (standard Lean multi-line)\n  //   ...content...\"  \u2190 closing \" at end of a content line\n  // Note: intermediate lines must be unescaped (e.g. \\\\\\\\ \u2192 \\\\) since\n  // tryCloseSingleLine only processes lines that contain the closing quote.\n  let accum = unescapeLeanString(afterQuote) + '\\n'\n  let i = startIdx + 1\n  while (i < lines.length) {\n    const line = lines[i]\n    const closed = tryCloseSingleLine(line)\n    if (closed !== null) {\n      // This line contains the closing \" \u2014 already unescaped by tryCloseSingleLine\n      accum += closed\n      const value = accum.replace(/^\\n/, '').replace(/\\n$/, '')\n      return { value, multiLine: true, endIdx: i }\n    }\n    accum += unescapeLeanString(line) + '\\n'\n    i++\n  }\n  // unterminated string \u2014 return what we have\n  const value = accum.replace(/^\\n/, '').replace(/\\n$/, '')\n  return { value, multiLine: true, endIdx: i - 1 }\n}\n\n/**\n * Unescape a Lean string fragment (without looking for a closing quote).\n * Handles: \\\\ \u2192 \\, \\\" \u2192 \", \\n \u2192 n, etc. \u2014 same logic as tryCloseSingleLine\n * but processes the entire input instead of stopping at an unescaped \".\n */\nfunction unescapeLeanString(s: string): string {\n  let result = ''\n  let i = 0\n  while (i < s.length) {\n    if (s[i] === '\\\\' && i + 1 < s.length) {\n      result += s[i + 1]\n      i += 2\n    } else {\n      result += s[i]\n      i++\n    }\n  }\n  return result\n}\n\n// \u2500\u2500\u2500 Top-level keyword detector \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nconst TOP_LEVEL_KEYWORDS = new Set([\n  'import',\n  'World',\n  'Level',\n  'Title',\n  'Introduction',\n  'Conclusion',\n  'Statement',\n  'NewTactic',\n  'NewTheorem',\n  'NewLemma',\n  'NewDefinition',\n  'TacticDoc',\n  'TheoremDoc',\n  'LemmaDoc',\n  'DefinitionDoc',\n  'Dependency',\n  'MakeGame',\n  'open',\n  'section',\n  'namespace',\n  'variable',\n  'set_option',\n])\n\nfunction isTopLevelKeyword(line: string): boolean {\n  const word = line.match(/^([A-Za-z_][A-Za-z0-9_]*)/)?.[1]\n  return word ? TOP_LEVEL_KEYWORDS.has(word) : false\n}\n\n// \u2500\u2500\u2500 Hint extraction \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/**\n * Extract Hint blocks from proof body lines.\n * Handles: `Hint \"...\"`, `Hint (hidden := true) \"...\"`, `Hint (strict := true) \"...\"`\n */\nfunction extractHints(proofLines: string[]): GameHint[] {\n  const hints: GameHint[] = []\n  let i = 0\n  while (i < proofLines.length) {\n    const line = proofLines[i]\n    const hintMatch = line.match(/^\\s*Hint\\s*(.*)$/)\n    if (!hintMatch) { i++; continue }\n\n    let rest = hintMatch[1]\n    let hidden = false\n    let strict = false\n\n    // Parse options like (hidden := true) (strict := true)\n    while (true) {\n      const optMatch = rest.match(/^\\s*\\(\\s*(hidden|strict)\\s*:=\\s*(true|false)\\s*\\)\\s*(.*)$/)\n      if (!optMatch) break\n      if (optMatch[1] === 'hidden') hidden = optMatch[2] === 'true'\n      if (optMatch[1] === 'strict') strict = optMatch[2] === 'true'\n      rest = optMatch[3]\n    }\n\n    rest = rest.trimStart()\n    if (!rest.startsWith('\"')) { i++; continue }\n\n    const afterQuote = rest.slice(1)\n    const single = tryCloseSingleLine(afterQuote)\n    if (single !== null) {\n      hints.push({ text: single, hidden, strict })\n      i++\n      continue\n    }\n\n    // Multi-line hint \u2014 closing \" may be on its own line or end a content line\n    let accum = unescapeLeanString(afterQuote) + '\\n'\n    i++\n    let closed = false\n    while (i < proofLines.length) {\n      const pl = proofLines[i]\n      const closedStr = tryCloseSingleLine(pl)\n      if (closedStr !== null) {\n        accum += closedStr\n        hints.push({ text: accum.replace(/^\\n/, '').replace(/\\n$/, ''), hidden, strict })\n        i++\n        closed = true\n        break\n      }\n      accum += unescapeLeanString(pl) + '\\n'\n      i++\n    }\n    if (!closed) {\n      // unterminated \u2014 push what we have\n      hints.push({ text: accum.replace(/^\\n/, '').replace(/\\n$/, ''), hidden, strict })\n    }\n  }\n  return hints\n}\n\n// \u2500\u2500\u2500 Statement extraction \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ninterface StatementResult {\n  signature: string      // \"Statement ... := by\"\n  proofLines: string[]   // lines of the proof body\n  endIdx: number         // last line index consumed\n}\n\n/**\n * Extract the Statement block starting at `startIdx`.\n * The line at startIdx begins with \"Statement\".\n * Accumulates until \":= by\" is found at end of a line, then collects\n * proof body lines until the next top-level keyword at column 0.\n */\nfunction extractStatementAndProof(\n  lines: string[],\n  startIdx: number,\n): StatementResult {\n  // Accumulate signature lines until \":= by\"\n  let sigLines: string[] = []\n  let i = startIdx\n\n  while (i < lines.length) {\n    const line = lines[i]\n    sigLines.push(line)\n    if (line.trimEnd().endsWith(':= by')) {\n      break\n    }\n    // Also handle `:= by` followed by a tactic on the same line after it\n    if (line.includes(':= by')) {\n      break\n    }\n    i++\n  }\n\n  const signature = sigLines.join('\\n')\n  i++ // move past the := by line\n\n  // Collect proof body: lines until next top-level keyword at column 0\n  const proofLines: string[] = []\n  while (i < lines.length) {\n    const line = lines[i]\n    // A line starting at col 0 with a known keyword ends the proof\n    if (line.length > 0 && line[0] !== ' ' && line[0] !== '\\t' && isTopLevelKeyword(line)) {\n      break\n    }\n    // Also a /-- docstring at col 0\n    if (line.startsWith('/--')) {\n      break\n    }\n    proofLines.push(line)\n    i++\n  }\n\n  return { signature, proofLines, endIdx: i - 1 }\n}\n\n// \u2500\u2500\u2500 Main parser \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/**\n * Parse a Lean game level file and return its LevelData.\n * Returns null if the file has no `Statement` (e.g. world intro files).\n */\nexport function parseLevelFile(\n  sourceFilePath: string,\n  solutionFilePath: string,\n): LevelData | null {\n  const content = fs.readFileSync(sourceFilePath, 'utf-8')\n  const lines = content.split('\\n')\n\n  let world = ''\n  let level = 0\n  let title = ''\n  let introduction = ''\n  let conclusion = ''\n  let statementDocstring = ''\n  let statementSignature = ''\n  let hints: GameHint[] = []\n  let hasStatement = false\n\n  let pendingDocstring = ''\n\n  let i = 0\n  while (i < lines.length) {\n    const line = lines[i]\n    const trimmed = line.trim()\n\n    // \u2500\u2500 Skip blank lines \u2500\u2500\n    if (trimmed === '') {\n      i++\n      continue\n    }\n\n    // \u2500\u2500 Comments (non-docstring) \u2500\u2500\n    if (trimmed.startsWith('--') && !trimmed.startsWith('/--')) {\n      i++\n      continue\n    }\n\n    // \u2500\u2500 Docstring /-- ... -/ \u2500\u2500\n    if (trimmed.startsWith('/--')) {\n      const docLines: string[] = [line]\n      if (!trimmed.endsWith('-/')) {\n        i++\n        while (i < lines.length) {\n          const dl = lines[i]\n          docLines.push(dl)\n          if (dl.trimEnd().endsWith('-/')) {\n            break\n          }\n          i++\n        }\n      }\n      // Strip /-- and -/ markers\n      let raw = docLines.join('\\n')\n      raw = raw.replace(/^\\/--\\s?/, '').replace(/-\\/$/, '').trim()\n      pendingDocstring = raw\n      i++\n      continue\n    }\n\n    // \u2500\u2500 import \u2500\u2500\n    if (trimmed.startsWith('import ')) {\n      pendingDocstring = ''\n      i++\n      continue\n    }\n\n    // \u2500\u2500 World \u2500\u2500\n    if (trimmed.startsWith('World ')) {\n      const rest = trimmed.slice('World '.length)\n      const res = extractLeanString(lines, i, rest)\n      if (res.value !== null) world = res.value\n      i = res.endIdx + 1\n      pendingDocstring = ''\n      continue\n    }\n\n    // \u2500\u2500 Level \u2500\u2500\n    if (trimmed.startsWith('Level ')) {\n      const num = parseInt(trimmed.slice('Level '.length).trim(), 10)\n      if (!isNaN(num)) level = num\n      pendingDocstring = ''\n      i++\n      continue\n    }\n\n    // \u2500\u2500 Title \u2500\u2500\n    if (trimmed.startsWith('Title ')) {\n      const rest = trimmed.slice('Title '.length)\n      const res = extractLeanString(lines, i, rest)\n      if (res.value !== null) title = res.value\n      i = res.endIdx + 1\n      pendingDocstring = ''\n      continue\n    }\n\n    // \u2500\u2500 Introduction \u2500\u2500\n    if (trimmed.startsWith('Introduction ')) {\n      const rest = trimmed.slice('Introduction '.length)\n      const res = extractLeanString(lines, i, rest)\n      if (res.value !== null) introduction = res.value\n      i = res.endIdx + 1\n      pendingDocstring = ''\n      continue\n    }\n\n    // \u2500\u2500 Conclusion \u2500\u2500\n    if (trimmed.startsWith('Conclusion ')) {\n      const rest = trimmed.slice('Conclusion '.length)\n      const res = extractLeanString(lines, i, rest)\n      if (res.value !== null) conclusion = res.value\n      i = res.endIdx + 1\n      pendingDocstring = ''\n      continue\n    }\n\n    // \u2500\u2500 Statement \u2500\u2500\n    if (trimmed.startsWith('Statement') && (trimmed.length === 9 || /^Statement[\\s(:]/.test(trimmed))) {\n      hasStatement = true\n      statementDocstring = pendingDocstring\n      pendingDocstring = ''\n\n      const result = extractStatementAndProof(lines, i)\n      statementSignature = result.signature\n      hints = extractHints(result.proofLines)\n      i = result.endIdx + 1\n      continue\n    }\n\n    // \u2500\u2500 Everything else (TacticDoc, NewTactic, etc.) \u2014 skip \u2500\u2500\n    pendingDocstring = ''\n    i++\n  }\n\n  if (!hasStatement) return null\n\n  return {\n    sourceFilePath,\n    solutionFilePath,\n    world,\n    level,\n    title,\n    introduction,\n    statementDocstring,\n    statementSignature,\n    hints,\n    conclusion,\n  }\n}\n\n// \u2500\u2500\u2500 Game directory scanner \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n/**\n * Recursively find all .lean files under `levelsDir`.\n */\nfunction findLeanFiles(dir: string): string[] {\n  const results: string[] = []\n  if (!fs.existsSync(dir)) return results\n  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {\n    const full = path.join(dir, entry.name)\n    if (entry.isDirectory()) {\n      // Skip directories with spaces \u2014 they are copies/backups, not valid Lean modules\n      if (!entry.name.includes(' ')) results.push(...findLeanFiles(full))\n    } else if (entry.isFile() && entry.name.endsWith('.lean')) {\n      results.push(full)\n    }\n  }\n  return results\n}\n\n/**\n * Compute the solution file path for a given source file.\n *\n * Source:   <gameRoot>/Game/Levels/<rest>.lean\n * Solution: <gameRoot>/Solutions/<rest>.lean\n */\nfunction computeSolutionPath(sourceFilePath: string, gameRoot: string): string {\n  const levelsDir = path.join(gameRoot, 'Game', 'Levels')\n  const relative = path.relative(levelsDir, sourceFilePath)\n  return path.join(gameRoot, 'Solutions', relative)\n}\n\n/**\n * Parse all level files in a game directory.\n * Returns only files that contain a Statement.\n */\nexport function parseGameDirectory(gameRoot: string): LevelData[] {\n  const levelsDir = path.join(gameRoot, 'Game', 'Levels')\n  const files = findLeanFiles(levelsDir)\n\n  const levels: LevelData[] = []\n  for (const file of files) {\n    const solutionPath = computeSolutionPath(file, gameRoot)\n    try {\n      const data = parseLevelFile(file, solutionPath)\n      if (data) levels.push(data)\n    } catch (e) {\n      console.error(`lean-game-vscode: failed to parse ${file}:`, e)\n    }\n  }\n\n  // Sort by world name then level number\n  levels.sort((a, b) => {\n    if (a.world !== b.world) return a.world.localeCompare(b.world)\n    return a.level - b.level\n  })\n\n  return levels\n}\n", "import * as fs from 'fs'\nimport * as path from 'path'\nimport { LevelData, WorldEdge } from './types'\n\n/**\n * Find the main game .lean file (Game.lean or <DirName>.lean).\n */\nfunction findGameLean(gameRoot: string): string | null {\n  const dirName = path.basename(gameRoot)\n  for (const candidate of ['Game.lean', `${dirName}.lean`]) {\n    const p = path.join(gameRoot, candidate)\n    if (fs.existsSync(p)) return p\n  }\n  return null\n}\n\n/**\n * Parse `Dependency X \u2192 Y` declarations from the game's main .lean file,\n * then supplement with implicit ordering edges inferred from world positions.\n *\n * Many Lean games only declare \"non-obvious\" prerequisites explicitly.\n * The sequential ordering (L1 \u2192 L2 \u2192 L3 \u2026) is implicit in the directory\n * naming convention used under Game/Levels/.\n *\n * Algorithm for implicit edges:\n *   \u2013 Map each world to its source directory using the parsed level paths\n *     (e.g., world \"L3Pset\" lives in \"\u2026/Game/Levels/L3Pset/\").\n *   \u2013 Extract the leading L<N> numeric prefix (e.g., L3) from that directory name.\n *   \u2013 Group worlds by prefix number.  Within each group, sort so that\n *     non-Pset directories (lectures, stories, \u2026) come before Pset directories\n *     \u2014 this matches the typical game authoring order.\n *   \u2013 For each world with no explicit predecessor:\n *       \u2022 Worlds in the first group: the very first world is the root; the\n *         rest depend on it (they are siblings one level below the opener).\n *       \u2022 Worlds in later groups N: depend on the \"anchor\" of group N-1,\n *         where anchor = first world in that group with no explicit predecessor\n *         (falling back to the very first world if all have predecessors).\n *\n * This places all no-predecessor worlds in the same L<N> group at the same\n * depth as siblings, giving the expected L1 \u2192 [L2 worlds] \u2192 [L3 worlds] \u2026\n * layered structure without requiring every dependency to be declared.\n */\nexport function parseGameDependencies(gameRoot: string, levels: LevelData[]): WorldEdge[] {\n  const gameLean = findGameLean(gameRoot)\n  if (!gameLean) return []\n\n  const content = fs.readFileSync(gameLean, 'utf-8')\n\n  // \u2500\u2500 1. Explicit Dependency edges \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  const explicitEdges: WorldEdge[] = []\n  for (const line of content.split('\\n')) {\n    const m = line.match(/^Dependency\\s+(\\S+)\\s+(?:\u2192|->)\\s+(\\S+)/)\n    if (m) explicitEdges.push({ from: m[1], to: m[2] })\n  }\n\n  // \u2500\u2500 2. World \u2192 source directory (from parsed levels' file paths) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  // sourceFilePath: \u2026/Game/Levels/<dir>/<file>.lean  \u2192  capture <dir>\n  const worldDir = new Map<string, string>()  // world name \u2192 directory name\n  for (const level of levels) {\n    if (worldDir.has(level.world)) continue\n    const m = level.sourceFilePath.match(/Game[/\\\\]Levels[/\\\\]([^/\\\\]+)/)\n    if (m) worldDir.set(level.world, m[1])\n  }\n\n  // \u2500\u2500 3. Group worlds by L<N> prefix of their source directory \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  const groupMap = new Map<number, Set<string>>()\n  for (const [world, dir] of worldDir) {\n    const m = dir.match(/^[Ll](\\d+)/)\n    if (!m) continue\n    const g = parseInt(m[1])\n    if (!groupMap.has(g)) groupMap.set(g, new Set())\n    groupMap.get(g)!.add(world)\n  }\n\n  if (groupMap.size === 0) return explicitEdges\n\n  // \u2500\u2500 4. Sort within each group: lecture/story directories first, Pset last \u2500\u2500\n  // Matching on the directory name (not the world name) keeps this robust.\n  const isPsetDir = (world: string) => /pset/i.test(worldDir.get(world) ?? '')\n\n  const groups = new Map<number, string[]>()\n  for (const [g, worldSet] of groupMap) {\n    const sorted = Array.from(worldSet).sort((a, b) => {\n      const pa = isPsetDir(a), pb = isPsetDir(b)\n      if (pa !== pb) return pa ? 1 : -1   // non-Pset first\n      // alphabetical within each sub-group\n      return (worldDir.get(a) ?? '').localeCompare(worldDir.get(b) ?? '')\n    })\n    groups.set(g, sorted)\n  }\n\n  const groupNums = Array.from(groups.keys()).sort((a, b) => a - b)\n\n  // \u2500\u2500 5. Track which worlds already have an explicit predecessor \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  const hasExplicitPred = new Set<string>()\n  for (const e of explicitEdges) hasExplicitPred.add(e.to)\n\n  // \u2500\u2500 6. Anchor = first world in a group without an explicit predecessor \u2500\u2500\u2500\u2500\u2500\u2500\n  function anchor(worldList: string[]): string | null {\n    return worldList.find(w => !hasExplicitPred.has(w)) ?? worldList[0] ?? null\n  }\n\n  // \u2500\u2500 7. Generate implicit edges \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  const implicitEdges: WorldEdge[] = []\n\n  for (let gi = 0; gi < groupNums.length; gi++) {\n    const worlds     = groups.get(groupNums[gi])!\n    const prevAnchor = gi > 0 ? anchor(groups.get(groupNums[gi - 1])!) : null\n\n    for (let wi = 0; wi < worlds.length; wi++) {\n      const world = worlds[wi]\n      if (hasExplicitPred.has(world)) continue  // already has a declared predecessor\n\n      if (gi === 0) {\n        // First group: the very first world is the root; later ones depend on it\n        if (wi > 0) implicitEdges.push({ from: worlds[0], to: world })\n      } else {\n        // Later groups: all no-predecessor worlds \u2192 depend on prev-group anchor\n        if (prevAnchor && prevAnchor !== world) {\n          implicitEdges.push({ from: prevAnchor, to: world })\n        }\n      }\n    }\n  }\n\n  return [...explicitEdges, ...implicitEdges]\n}\n", "import * as fs from 'fs'\nimport * as path from 'path'\nimport { LevelData } from '../parser/types'\n\n/**\n * Compute the Lean module import path from an absolute source file path.\n * e.g. /path/to/RealAnalysisGame/Game/Levels/L6Pset/L6Pset3.lean\n *   -> Game.Levels.L6Pset.L6Pset3\n * Falls back to 'Game.Metadata' if the path doesn't match the expected pattern.\n */\nfunction computeImportPath(sourceFilePath: string): string {\n  const m = sourceFilePath.match(/[/\\\\](Game[/\\\\]Levels[/\\\\].+)$/)\n  if (!m) return 'Game.Metadata'\n  return m[1].replace(/\\.lean$/, '').replace(/[/\\\\]/g, '.')\n}\n\n/**\n * Convert a Statement DSL signature to a regular Lean theorem declaration.\n * Strips \"Statement [optionalName]\" and replaces with \"theorem lean_game_solution\".\n * This avoids re-registering world/level metadata when the source file is imported.\n */\nfunction statementToTheorem(sig: string): string {\n  return sig.replace(\n    /^Statement(\\s+[A-Za-z_][A-Za-z0-9_'.]*)?(?=\\s|\\(|:)/m,\n    'theorem lean_game_solution',\n  )\n}\n\n/**\n * Generate the content of a solution stub file for the given level.\n * Imports the source level file (not just Game.Metadata) so that all\n * definitions used in the statement (e.g. SeqLim) are in scope.\n */\nfunction generateSolutionContent(level: LevelData): string {\n  const importPath = computeImportPath(level.sourceFilePath)\n\n  const lines: string[] = [\n    '-- Auto-generated by lean-game-vscode. Edit the proof below.',\n    `import ${importPath}`,\n    '',\n  ]\n\n  if (level.statementDocstring) {\n    lines.push(`/-- ${level.statementDocstring} -/`)\n  }\n\n  // Use a regular theorem (not Statement DSL) so there's no duplicate level\n  // registration when the source file is imported above.\n  const sig = statementToTheorem(level.statementSignature.trimEnd())\n  lines.push(sig)\n  lines.push('  sorry')\n  lines.push('')\n\n  return lines.join('\\n')\n}\n\n/**\n * Write a solution stub file for `level`, unless it already exists.\n * Returns 'created' | 'exists' | 'error'.\n */\nexport function generateSolutionFile(\n  level: LevelData,\n  overwrite = false,\n): 'created' | 'exists' | 'error' {\n  const filePath = level.solutionFilePath\n  try {\n    if (fs.existsSync(filePath) && !overwrite) {\n      return 'exists'\n    }\n    fs.mkdirSync(path.dirname(filePath), { recursive: true })\n    fs.writeFileSync(filePath, generateSolutionContent(level), 'utf-8')\n    return 'created'\n  } catch (e) {\n    console.error(`lean-game-vscode: failed to write ${filePath}:`, e)\n    return 'error'\n  }\n}\n\n/**\n * Generate solution stubs for all levels in the array.\n * Skips existing files unless `overwrite` is true.\n */\nexport function generateAllSolutions(\n  levels: LevelData[],\n  overwrite = false,\n): { created: number; skipped: number; errors: number } {\n  let created = 0\n  let skipped = 0\n  let errors = 0\n\n  for (const level of levels) {\n    const result = generateSolutionFile(level, overwrite)\n    if (result === 'created') created++\n    else if (result === 'exists') skipped++\n    else errors++\n  }\n\n  return { created, skipped, errors }\n}\n"],
  "mappings": "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",
  "names": ["vscode", "vscode", "path", "fs", "vscode", "fs", "vscode", "fs", "vscode", "fs", "path", "value", "relative", "fs", "path", "fs", "path", "IMPORT_MARKER"]
}
