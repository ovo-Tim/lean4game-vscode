import * as fs from 'fs'
import * as path from 'path'
import { LevelData } from '../parser/types'

/**
 * Compute the Lean module import path from an absolute source file path.
 * e.g. /path/to/RealAnalysisGame/Game/Levels/L6Pset/L6Pset3.lean
 *   -> Game.Levels.L6Pset.L6Pset3
 * Falls back to 'Game.Metadata' if the path doesn't match the expected pattern.
 */
function computeImportPath(sourceFilePath: string): string {
  const m = sourceFilePath.match(/[/\\](Game[/\\]Levels[/\\].+)$/)
  if (!m) return 'Game.Metadata'
  return m[1].replace(/\.lean$/, '').replace(/[/\\]/g, '.')
}

/**
 * Convert a Statement DSL signature to a regular Lean theorem declaration.
 * Strips "Statement [optionalName]" and replaces with "theorem lean_game_solution".
 * This avoids re-registering world/level metadata when the source file is imported.
 */
function statementToTheorem(sig: string): string {
  return sig.replace(
    /^Statement(\s+[A-Za-z_][A-Za-z0-9_'.]*)?(?=\s|\(|:)/m,
    'theorem lean_game_solution',
  )
}

/**
 * Generate the content of a solution stub file for the given level.
 * Imports the source level file (not just Game.Metadata) so that all
 * definitions used in the statement (e.g. SeqLim) are in scope.
 */
function generateSolutionContent(level: LevelData): string {
  const importPath = computeImportPath(level.sourceFilePath)

  const lines: string[] = [
    '-- Auto-generated by lean-game-vscode. Edit the proof below.',
    `import ${importPath}`,
    '',
  ]

  if (level.statementDocstring) {
    lines.push(`/-- ${level.statementDocstring} -/`)
  }

  // Use a regular theorem (not Statement DSL) so there's no duplicate level
  // registration when the source file is imported above.
  const sig = statementToTheorem(level.statementSignature.trimEnd())
  lines.push(sig)
  lines.push('  sorry')
  lines.push('')

  return lines.join('\n')
}

/**
 * Write a solution stub file for `level`, unless it already exists.
 * Returns 'created' | 'exists' | 'error'.
 */
export function generateSolutionFile(
  level: LevelData,
  overwrite = false,
): 'created' | 'exists' | 'error' {
  const filePath = level.solutionFilePath
  try {
    if (fs.existsSync(filePath) && !overwrite) {
      return 'exists'
    }
    fs.mkdirSync(path.dirname(filePath), { recursive: true })
    fs.writeFileSync(filePath, generateSolutionContent(level), 'utf-8')
    return 'created'
  } catch (e) {
    console.error(`lean-game-vscode: failed to write ${filePath}:`, e)
    return 'error'
  }
}

/**
 * Generate solution stubs for all levels in the array.
 * Skips existing files unless `overwrite` is true.
 */
export function generateAllSolutions(
  levels: LevelData[],
  overwrite = false,
): { created: number; skipped: number; errors: number } {
  let created = 0
  let skipped = 0
  let errors = 0

  for (const level of levels) {
    const result = generateSolutionFile(level, overwrite)
    if (result === 'created') created++
    else if (result === 'exists') skipped++
    else errors++
  }

  return { created, skipped, errors }
}
